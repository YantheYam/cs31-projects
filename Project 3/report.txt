Ryan Lim, 005969674
Part A
For me, there were two notable obstacles that I had to overcome. The first was figuring out how to use the substr function to cut the input into each individual batch, as the user can input multiple QC batches at once. At first, it was really hard to figure out the logic as to how to use the loops to increment correctly and cut the input into substrings, but once I figured it out then it was smooth sailing from there. After figuring out how to splice the input string into substrings, I decided to put all of my actual QC checks in a helper function called isValidQCHelper to simplify my code and make it look less messy.
The second obstacle that I had to overcome was figuring out how to count the number that came after Q, p, or d if it was multiple digits. In the end, I had to use a temporary string, where I used a for loop to concatenate each digit after the Q, p, or d as a character to the temp string, and then after going through all the digits using the stoi function to convert the string into an integer and thus finding the total number that came after Q, p, or d. Once again, it wasn't the most straightforward process figuring out the logic for it, but once I figured it out it was once again smooth sailing from there.
I guess I could also call coding the isValidQC function an obstacle as well. It took the most time and effort out of all of the functions, and also was the hardest, trying to include every check necessarily to match the requirements in the project specifications.

Part B
The first part of my program besides the preprocessor directives was to prototype my functions, allowing me to have the functions in whatever order I wanted (in particular, having the main function on top).

Considering the main routine is not relevant to this project, I will proceed to describe the next function, which would be bool isValidQC(string results). I used this function to split the input string (string results) into substrings (individual test batches), and then called a helper function that included the bulk of the validity checks, using the substring as the input. First, I declared int startPos and int endPos, initializing startPos to 0 and endPos to 1, as well as declaring string subResults. The first check I included was to check that the string being inputted had a length of at least 6, as the shortest valid string length is 6 (Q(digit)p(digit)d(digit) or Q(digit)d(digit)p(digit)). If the string failed this check, then the function would return false.
Next, I included a while loop that would run while endPos was less than or equal to the size of the input string (results). This while loop is what I used to split the input string into substrings if there were multiple test batches within the input. Inside the while loop, I also had a for loop which I used purely to increment endPos until it either reached the end of the string or it reached another Q. Once the for loop finished, I then utilized the substr function to create a substring from the input string (results), starting at startPos with a length of endPos - startPos, which would lead to a substring starting at Q and ending at the character either right in front of the next Q or at the end of the string. Before calling the helper function, I included another check to see if subResults was the correct length (length of at least 6). Next, I called the helper function that I created which included all of the actual checks for a valid test string, bool isValidQCHelper(string subResults). I called it within an if statement, such that if the helper function returned false (i.e. the test string was invalid) then it would return false. If the helper function returns true, then I set startPos to endPos and incremented endPos, and since this is still within the while loop, then this process would repeat until endPos became greater than the length of the input string.
Once the while loop finished, I had the function return true as that would mean that all of the substrings were valid QC test result batches.

The next function in my program is bool isValidQCHelper(string subResults), which contained the actual checks if the batch was valid or not. I chose to split the input string into individual QC tests so that it would be a lot easier to write the checks needed to see if the strings are valid, and I chose to use a helper function to keep the isValidQC function simpler and cleaner.
First, I declared int numQ, numP, and numD, initializing all of them to 0, as well as declaring a temp string. The first set of checks I included was if the test batch starts with Q (see if subResults[0] is a Q), if the batch was the correct size (i.e. if it was greater than or equal to length 6), and if there was a 0 after Q (see if subResults[1] is 0 or not). If any of these failed, then the function would return false.
The next check was to check for leading zeroes, and to do this I had a for loop which incremented int i starting at 0 until it reached the end of the string, checking if any characters in the string were 0 (subResults[i]), and if so, if the character after it was a digit using the isdigit function (subResults[i + 1]). If it was a digit, then the function would return false.
The next check was to make sure that all letters were either Q, p, or d, and that there were no spaces in the string. To do this, I had another for loop that incremented i starting at 0 until the end of the string. I then included an if statement that checked if subResults[i] was a space, and if so then it would return false. I included another if statement that checked if subResults[i] was a letter using the isalpha function, and if so, there was another if statement nested within that checked if subResult[i] was either Q, p, or d. If not, then the function would return false.
The next check was to check that there was only one Q, p, and D in the string, and to do this I first had to declare int qCheck, pCheck, and dCheck, initializing them to 0. Once again, I included a for loop starting at int i = 0 and incrementing i until the end of the string. Inside the for loop, I included if statements checking if subResults[i] was either Q, p, or d, and if so qCheck, pCheck, or dCheck would be incremented respectively. After the for loop, I included an if statement checking if qCheck, pCheck, and dCheck all equaled 1, and if they didn't then the function would return false.
The next check was to check that the number of passes and defects added together would equal the number of total tests. This check would utilize numQ, numP, numD, and the temp string that I declared at the beginning of the function. Once again, I included a for loop that started int i at 0 and continued to increment it until it reached the end of the string. Within this, I included an if statement that checked if subResults[i] was either Q, p, or d. If it was, then I nested another if statement checking if the next character (subResults[i + 1]) was a digit with the isdigit function, and if it wasn't then the function would return false. This checked that Q, p, and d were followed by a number.
After this, I included another if statement checking if subResults[i] was Q. If so, then I nested a for loop that started int k at i + 1 (making k the position of the character directly after Q) and incremented k as long as subResults[k] was a number. Within this for loop, I added subResults[k] to the previously declared temp string, and once the for loop exited (subResults[k] wasn't a number anymore) then I used the stoi function to convert my temp string into an integer, and set this equal to numQ. I then set the temp string back to empty.
I included two more if statements to repeat this process with p and d, using numP and numD respectively. This allowed me to get the total number of tests (number after Q), passes (number after p), and defects (number after d) even if the number had two or more digits.
Once this was all done, I had one last if statement that checked if numQ equaled numP added to numD (i.e. if the total number of runs equaled the number of passes and the number of defects), and if not then the function would return false. If the function had not already returned false (i.e. the batch was valid), then the function would return true.

The next function I had was int passQC(string results), which returns the total number of passes in the entire string. First, I had an if statement checking that isValidQC returned true, and if it didn't then the function would return -1 as stated in the project guidelines.
Next, I declared int totalPasses and another temp string, to utilize the method that I used in isValidQCHelper. Once again, I included a for loop starting at int i = 0 and incrementing i until it reached the end of the string. Within this for loop, I included an if statement checking if results[i] was a p, and if it was then I included a for loop nested within this if statement that started int k at i + 1 (the character directly after results[i]) and incremented k as long as results[k] was still a digit. Within this for loop, I added results[k] to my temp string.
Once this for loop exited, I converted my temp string to an integer using the stoi function, and added this to totalPasses. I added it instead of setting it equal as seen in isValidQCHelper in case there were multiple test batches within the input string. I then set the temp to empty again.
This would continue running until the initial for loop reached the end of the string, and once it did then I returned totalPasses.

The next function I had was int defectQC(string results). This function is identical to passQC, with the only difference being it checks for the total number of defects rather than the total number of passes. Hence, instead of totalPasses I used totalDefects, as well as checking for d instead of p in the for loop.

The next function I had was int totalQC(string results). Once again, this function is identical to passQC and defectQC, with the only difference being that it checked for the total number of tests ran rather than the total number of passes or defects. Hence, instead of totalPasses or totalDefects I used totalTests, and the for loop checked for Q instead of p or d.

The final function I had was int batches(string batches), which returns the total number of tests being reported. Once again, I first checked to see if the input string was valid by calling isValidQC, and if not then the function would return -1 as stated in the specs. I then declared the variable int totalBatches and initialized it to 0.
After this, I had a for loop that started at int i = 0 and incremented i until it reached the end of the string. Within this for loop, I included an if statement that checked if results[i] was Q, and if so then I incremented totalBatches. In other words, I was simply checking for the total number of Qs in the string.
Once the for loop exited, I had the function return totalBatches.



Part C
"Q5p2d3" (tests if program handles a valid test string correctly)
"Q8d5p3" (tests if program works when d is before p, compared to p before d in the previous test case)
"Q25p10d15" (tests if program works when numbers are greater than one digit)
"Q30p10d20Q10p5d5Q6d3p3" (tests if program can handle multiple batches in one input)
"q5p2d3" (tests if program recognizes lowercase q and fails test case accordingly)
"Q6pd6" (tests if program recognizes no number after p and fails test case accordingly)
"Q6p6d" (tests if program recognizes no number after d and fails test case accordingly)
"Q6p6d0Q5p3d2   Q2p1d1 adkasdks" (tests if program recognizes extra characters and fails test case accordingly)
"Q0006p0003d0003" (tests if program recognizes leading zeroes and fails test case accordingly)
"Q6p3d2" (tests if program recognizes # of p and # of d don't equal number of runs and fails test case accordingly)
"Q0p0d0" (tests if program recognizes batch is zero and fails test case accordingly)
"Q6p3d3Q" (tests what happens if second substring isn't complete and if program will fail test case accordingly)
"Q5p2d3Qp0d0" (another test of first batch being valid but second batch not)
"ABNJSF12ufAFi90210idaD" (tests what happens if there are no Q, p, or d, and if program will fail test case accordingly)
"" (tests if program can handle empty string)